#include "MultiGraph.h"
#include "Exceptions.h"
#include "IntPair.h"
#include <iostream>
#include <iomanip>
#include <fstream>
#define INF (float)((1e+300) * (1e+300) )
//=======================//
// Implemented Functions //
//=======================//
MultiGraph::MultiGraph()
{}

MultiGraph::MultiGraph(const std::string& filePath)
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    // Tokens
    std::string tokens[5];
    std::ifstream mapFile(filePath.c_str());

    if(!mapFile.is_open())
    {
        std::cout << "Unable to open " << filePath << std::endl;
        return;
    }

    // Read line by line
    std::string line;
    while (std::getline(mapFile, line))
    {
        // Empty Line Skip
        if(line.empty()) continue;
        // Comment Skip
        if(line[0] == '#') continue;

        // Tokenize the line
        int i = 0;
        std::istringstream stream(line);
        while(stream >> tokens[i]) i++;

        // Single token (Meaning it is a vertex)
        if(i == 1)
        {
            InsertVertex(tokens[0]);
        }
        // Exactly 5 tokens (Meaning it is an edge)
        else if(i == 5)
        {
            // Rename vars for readablity
            const std::string& vertexFromName = tokens[0];
            const std::string& vertexToName = tokens[1];
            const std::string& edgeName = tokens[2];
            float weight0 = static_cast<float>(std::atof(tokens[3].c_str()));
            float weight1 = static_cast<float>(std::atof(tokens[4].c_str()));
            AddEdge(edgeName, vertexFromName, vertexToName,
                    weight0, weight1);
        }
        else std::cerr << "Token Size Mismatch" << std::endl;
    }
}

void MultiGraph::PrintPath(const std::vector<int>& orderedVertexEdgeIndexList,
                           float heuristicWeight,
                           bool sameLine) const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this file !       //
    // ============================= //

    // Name is too long
    const std::vector<int>& ove = orderedVertexEdgeIndexList;
    // Invalid list
    // At least three items should be available
    if(ove.size() < 3) return;

    // Check vertex and an edge
    for(size_t i = 0; i < orderedVertexEdgeIndexList.size(); i += 2)
    {
        int vertexId = ove[i];
        if(vertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }


        const GraphVertex& vertex = vertexList[vertexId];
        std::cout << vertex.name;
        if(!sameLine) std::cout << "\n";
        // Only find and print the weight if next is available
        if(i == ove.size() - 1) break;
        int nextVertexId = ove[i + 2];
        if(nextVertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                    << " not found!" << std::endl;
            return;
        }

        // Find the edge between these two vertices
        int localEdgeId = ove[i + 1];
        if(localEdgeId >= static_cast<int>(vertex.edges.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "EdgeId " << localEdgeId
                      << " not found in " << vertexId << "!" << std::endl;
            return;
        }

        const GraphEdge& edge = vertex.edges[localEdgeId];

        // Combine with heuristic (linear interpolation)
        float weight = Lerp(edge.weight[0], edge.weight[1],
                            heuristicWeight);

        std::cout << "-" << std::setfill('-')
                  << std::setw(4)
                  << weight << "->";
    }
    // Print endline on the last vertex if same line is set
    if(sameLine) std::cout << "\n";
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

void MultiGraph::PrintEntireGraph() const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    for(size_t i = 0; i < vertexList.size(); i++)
    {
        const GraphVertex& v = vertexList[i];
        std::cout << v.name << "\n";
        for(size_t j = 0; j < v.edges.size(); j++)
        {
            const GraphEdge& edge = v.edges[j];

            // List the all vertex names and weight
            std::cout << "    -"
                      << std::setfill('-')
                      << std::setw(4) << edge.weight[0]
                      << "-"
                      << std::setw(4) << edge.weight[1]
                      << "-> ";
            std::cout << vertexList[edge.endVertexIndex].name;
            std::cout << " (" << edge.name << ")" << "\n";
        }
    }
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

//=======================//
//          TODO         //
//=======================//
float MultiGraph::Lerp(float w0, float w1, float alpha)
{
    /* TODO */
    float B = w0*(1-alpha) + w1*alpha ;
    return B;
}

void MultiGraph::InsertVertex(const std::string& vertexName)
{
    /* TODO */
    int i=0;
    for(;i<vertexList.size();i++){
        if(vertexList[i].name==vertexName) throw DuplicateVertexException(vertexName);
    }
    GraphVertex new_comer;
    new_comer.name=vertexName;
    vertexList.push_back(new_comer);
}

void MultiGraph::RemoveVertex(const std::string& vertexName)
{
    /* TODO */
    int i=0, j=0, z=0;
    bool flag=false;
    for(;i<vertexList.size();i++){
        if(vertexList[i].name==vertexName) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexName);

    for(;j<vertexList.size();j++){
        for(z=0;z<vertexList[j].edges.size();z++){
           if(vertexList[j].edges[z].endVertexIndex==i){
                vertexList[j].edges.erase(vertexList[j].edges.begin()+z); //direkt [z] olur mu acaba?
           }
        }   
    }
    vertexList.erase(vertexList.begin()+i);
}

void MultiGraph::AddEdge(const std::string& edgeName,
                         const std::string& vertexFromName,
                         const std::string& vertexToName,
                         float weight0, float weight1)
{
    /* TODO */
    int i=0, j=0, z=0;
    bool flag=false;
    for(;i<vertexList.size();i++){
        if(vertexList[i].name==vertexFromName) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexFromName);

    flag=false;
    for(;j<vertexList.size();j++){
        if(vertexList[j].name==vertexToName) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexToName);

    for(;z<vertexList[i].edges.size();z++){
           if((vertexList[i].edges[z].name==edgeName) && (vertexList[i].edges[z].endVertexIndex==j)) throw SameNamedEdgeException(edgeName,vertexFromName,vertexToName);
    }
    GraphEdge new_comer;
    new_comer.name=edgeName;
    new_comer.endVertexIndex=j;
    new_comer.weight[0]=weight0;
    new_comer.weight[1]=weight1;
    vertexList[i].edges.push_back(new_comer);
}

void MultiGraph::RemoveEdge(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName)
{
    /* TODO */
    int i=0, j=0, z=0;
    bool flag=false;
    for(;i<vertexList.size();i++){
        if(vertexList[i].name==vertexFromName) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexFromName);

    flag=false;
    for(;j<vertexList.size();j++){
        if(vertexList[j].name==vertexToName) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexToName);

    for(;z<vertexList[i].edges.size();z++){
        if((vertexList[i].edges[z].name==edgeName)&&(vertexList[i].edges[z].endVertexIndex==j)) {vertexList[i].edges.erase(vertexList[i].edges.begin()+z); return;}   
    }
    throw EdgeNotFoundException(vertexFromName,edgeName);

}
GraphEdge MultiGraph::FindEdge(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName) const {
    int i=0, j=0, z=0;
    bool flag=false;
    for(;i<vertexList.size();i++){
        if(vertexList[i].name==vertexFromName) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexFromName);

    flag=false;
    for(;j<vertexList.size();j++){
        if(vertexList[j].name==vertexToName) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexToName);

    for(;z<vertexList[i].edges.size();z++){
        if((vertexList[i].edges[z].name==edgeName)&&(vertexList[i].edges[z].endVertexIndex==j)) return vertexList[i].edges[z];
    }
    throw EdgeNotFoundException(vertexFromName,edgeName);
}

int MultiGraph::FindVertex(const std::string& vertexName) const {
    int i=0;
    bool flag=false;
    for(;i<vertexList.size();i++){
        if(vertexList[i].name==vertexName) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexName);
    return i;
}

GraphVertex MultiGraph::FindVertex(const int i) const {
    return vertexList[i];
}
int MultiGraph::GetSize() const {
    return vertexList.size();
}


bool MultiGraph::HeuristicShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                       const std::string& vertexNameFrom,
                                       const std::string& vertexNameTo,
                                       float heuristicWeight) const
{
    /* TODO */
    int i=0, j=0, z=0;
    bool flag=false;
    for(;i<vertexList.size();i++){
        if(vertexList[i].name==vertexNameFrom) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexNameFrom);

    flag=false;
    for(;j<vertexList.size();j++){
        if(vertexList[j].name==vertexNameTo) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexNameTo);
    // i ve j from ve to indexleri olmuş oldu.

    std::vector<int> prev_vertex;
    std::vector<float> distance_array;
    std::vector<bool> known_set;
    std::vector<int> prev_edges;
    //lets initialize these arrays
    for(int a=0;a<vertexList.size();a++){
        prev_vertex.push_back(-1); //NULL yerine -1 kullandim
    }

    for(int a=0;a<vertexList.size();a++){
        if(a==i) distance_array.push_back(0); 
        else distance_array.push_back(INF);
    
    }

    for(int a=0;a<vertexList.size();a++){
        known_set.push_back(false);
    }

    for(int a=0;a<vertexList.size();a++){
        prev_edges.push_back(-1); //NULL yerine -1 kullandim
    }
    MinPairHeap<float, int>  my_heap; //float(key) distance, int(value) index of that vertex
    for(int a=0;a<vertexList.size();a++){
        Pair<float,int> temp;
        temp.key=distance_array[a];
        temp.value=a;
        my_heap.push(temp);
    }
    float new_distance;
    while(!my_heap.empty()) {
        int curr_vertex_index= my_heap.top().value; //yani şimdi edgelerini gezeceğimiz vertexin indexi
        if(known_set[curr_vertex_index]==1) {my_heap.pop(); continue; }
        known_set[curr_vertex_index]=1;
        my_heap.pop();
        for(int b=0; b<vertexList[curr_vertex_index].edges.size();b++){

            GraphEdge curr_edge=vertexList[curr_vertex_index].edges[b];
            new_distance=(distance_array[curr_vertex_index] + Lerp(curr_edge.weight[0],curr_edge.weight[1],heuristicWeight));

            if(new_distance<distance_array[curr_edge.endVertexIndex]){
                distance_array[curr_edge.endVertexIndex]=new_distance;
                prev_vertex[curr_edge.endVertexIndex]=curr_vertex_index;
                Pair<float,int> updated;
                updated.key=new_distance;
                updated.value=curr_edge.endVertexIndex;
                my_heap.push(updated);
                prev_edges[curr_edge.endVertexIndex]=b;
            }
        }
    }

   
    if (distance_array[j]==INF) return false;
    std::vector<int> reverse;
    int ind=j;
    reverse.push_back(j);

    while(ind!=i){
        reverse.push_back(prev_edges[ind]);
        reverse.push_back(prev_vertex[ind]);
        ind=prev_vertex[ind];
    }
    for(int x=reverse.size()-1; x>-1 ;x--){
        orderedVertexEdgeIndexList.push_back(reverse[x]);
    }

    return true;
}

bool MultiGraph::FilteredShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                      const std::string& vertexNameFrom,
                                      const std::string& vertexNameTo,
                                      float heuristicWeight,
                                      const std::vector<std::string>& edgeNames) const
{
    /* TODO */
    int i=0, j=0, z=0;
    bool flag=false;
    for(;i<vertexList.size();i++){
        if(vertexList[i].name==vertexNameFrom) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexNameFrom);

    flag=false;
    for(;j<vertexList.size();j++){
        if(vertexList[j].name==vertexNameTo) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexNameTo);
    // i ve j from ve to indexleri olmuş oldu.

    std::vector<int> prev_vertex;
    std::vector<float> distance_array;
    std::vector<bool> known_set;
    std::vector<int> prev_edges;
    //lets initialize these arrays
    for(int a=0;a<vertexList.size();a++){
        prev_vertex.push_back(-1); //NULL yerine -1 kullandim
    }

    for(int a=0;a<vertexList.size();a++){
        if(a==i) distance_array.push_back(0); 
        else distance_array.push_back(INF);
    
    }

    for(int a=0;a<vertexList.size();a++){
        known_set.push_back(false);
    }

    for(int a=0;a<vertexList.size();a++){
        prev_edges.push_back(-1); //NULL yerine -1 kullandim
    }
    MinPairHeap<float, int>  my_heap; //float(key) distance, int(value) index of that vertex
    for(int a=0;a<vertexList.size();a++){
        Pair<float,int> temp;
        temp.key=distance_array[a];
        temp.value=a;
        my_heap.push(temp);
    }
    float new_distance;
    while(!my_heap.empty()) {
        int curr_vertex_index= my_heap.top().value; //yani şimdi edgelerini gezeceğimiz vertexin indexi
        if(known_set[curr_vertex_index]==1) {my_heap.pop(); continue; }
        known_set[curr_vertex_index]=1;
        my_heap.pop();
        for(int b=0; b<vertexList[curr_vertex_index].edges.size();b++){

            GraphEdge curr_edge=vertexList[curr_vertex_index].edges[b];
            bool isIn=false;
            for(int f=0;f<edgeNames.size();f++) {
                if(edgeNames[f]==curr_edge.name) { isIn=true; break;}
            }
            if(isIn) continue;

            new_distance=(distance_array[curr_vertex_index] + Lerp(curr_edge.weight[0],curr_edge.weight[1],heuristicWeight));

            if(new_distance<distance_array[curr_edge.endVertexIndex]){
                distance_array[curr_edge.endVertexIndex]=new_distance;
                prev_vertex[curr_edge.endVertexIndex]=curr_vertex_index;
                Pair<float,int> updated;
                updated.key=new_distance;
                updated.value=curr_edge.endVertexIndex;
                my_heap.push(updated);
                prev_edges[curr_edge.endVertexIndex]=b;
            }
        }
    }

   
    if (distance_array[j]==INF) return false;
    std::vector<int> reverse;
    int ind=j;
    reverse.push_back(j);

    while(ind!=i){
        reverse.push_back(prev_edges[ind]);
        reverse.push_back(prev_vertex[ind]);
        ind=prev_vertex[ind];
    }
    for(int x=reverse.size()-1; x>-1 ;x--){
        orderedVertexEdgeIndexList.push_back(reverse[x]);
    }

    return true;
}




int MultiGraph::BiDirectionalEdgeCount() const
{
    /* TODO */
    int i=0, j=0, z=0;
    int count=0;
    for(i=0;i<vertexList.size();i++){ //i vertexin indexi
        for(j=0;j<vertexList[i].edges.size();j++){ // j= i vertexinin edgelerinin indexi
        std::string search_name= vertexList[i].edges[j].name;
        int target_vertex=vertexList[i].edges[j].endVertexIndex;
            for(z=0;z<vertexList[target_vertex].edges.size();z++){
                if((vertexList[target_vertex].edges[z].name==search_name) && (vertexList[target_vertex].edges[z].endVertexIndex==i))
                {count++; break;}
            }

        }
    }
    return count/2;
}

int MultiGraph::MaxDepthViaEdgeName(const std::string& vertexName,
                                    const std::string& edgeName) const
{   int i=0;
    bool flag=false;
    for(i=0;i<vertexList.size();i++){
        if(vertexList[i].name==vertexName) {flag=true; break;}
    }
    if(flag==false) throw VertexNotFoundException(vertexName);
    std::vector<int> prev_vertex;
    std::vector<float> distance_array;
    std::vector<bool> known_set;

    for(int a=0;a<vertexList.size();a++){
        prev_vertex.push_back(-1); //NULL yerine -1 kullandim
    }

    for(int a=0;a<vertexList.size();a++){
        distance_array.push_back(0);
    
    }

    for(int a=0;a<vertexList.size();a++){
        if(a==i) known_set.push_back(true);
        known_set.push_back(false);
    }

    MaxPairHeap<int, int>  my_que;
    Pair<int,int> temp;
    temp.key=1;
    temp.value=i;
    my_que.push(temp);

    while(!my_que.empty()) {
        int curr_vertex_index= my_que.top().value; //yani şimdi edgelerini gezeceğimiz vertexin indexi
        my_que.pop();
        for(int b=0; b<vertexList[curr_vertex_index].edges.size();b++){
            int adj=vertexList[curr_vertex_index].edges[b].endVertexIndex;
            if(known_set[adj]==0 && (vertexList[curr_vertex_index].edges[b].name==edgeName)){
                prev_vertex[adj]=curr_vertex_index;
                distance_array[adj]=distance_array[curr_vertex_index]+1;
                Pair<int,int> new_vertex;
                new_vertex.key=1;
                new_vertex.value=adj;
                my_que.push(new_vertex);
                known_set[adj]=1;
            }
        }
    }
    int j=0;
    int maks=0;
    for(j=0;j<distance_array.size();j++){
        if(distance_array[j]>maks) maks=distance_array[j];
    }
    return maks;
}